#!/usr/bin/env python3
import os
import signal
import subprocess
import gi

# GTK and AppIndicator setup
gi.require_version('Gtk', '3.0')
gi.require_version('AppIndicator3', '0.1')
from gi.repository import Gtk, AppIndicator3, GLib

class CDSyncIndicator:
    def __init__(self):
        # 1. Resolve paths and service names
        self.base_dir = os.path.dirname(os.path.abspath(__file__))
        folder_name = os.path.basename(self.base_dir)
        
        # Matches the names generated by install.sh
        self.service_name = f"cdsync-{folder_name}-watcher.service"
        self.timer_name = f"cdsync-{folder_name}-poll.timer"
        
        # Unique ID for the indicator
        self.APPINDICATOR_ID = f"cdsync_indicator_{folder_name}"

        # 2. Configure Icons (System Standard Icons)
        # Tip: Use 'gtk3-icon-browser' to find standard icon names on your system.
        # Common options: 'view-refresh', 'sync-synchronizing', 'network-transmit-receive'
        self.icon_active = "mail-send-receive"       
        # Common options: 'network-offline', 'process-stop', 'media-playback-pause'
        self.icon_inactive = "dialog-warning"   
        
        self.indicator = AppIndicator3.Indicator.new(
            self.APPINDICATOR_ID,
            self.icon_inactive,
            AppIndicator3.IndicatorCategory.APPLICATION_STATUS
        )
        self.indicator.set_status(AppIndicator3.IndicatorStatus.ACTIVE)

        # 3. Create the Menu
        self.menu = Gtk.Menu()
        
        # Status Label
        # set_sensitive(True) removes the "grayed out" look. 
        # We use Emojis to add color since GTK menus follow system themes.
        self.item_label = Gtk.MenuItem(label="CDSync: Checking...")
        self.item_label.set_sensitive(True) 
        self.menu.append(self.item_label)

        # Separator
        self.menu.append(Gtk.SeparatorMenuItem())

        # Toggle Button (Enable/Disable)
        self.item_toggle = Gtk.MenuItem(label="Enable Sync")
        self.item_toggle.connect("activate", self.toggle_service)
        self.menu.append(self.item_toggle)

        # Separator
        self.menu.append(Gtk.SeparatorMenuItem())
        
        # Manual Sync Button
        self.item_sync = Gtk.MenuItem(label="Sync Now")
        self.item_sync.connect("activate", self.manual_sync)
        self.menu.append(self.item_sync)

        # Quit Button (Closes tray icon only, service keeps running)
        item_quit = Gtk.MenuItem(label="Quit Tray Icon")
        item_quit.connect("activate", self.quit)
        self.menu.append(item_quit)

        self.menu.show_all()
        self.indicator.set_menu(self.menu)

        # 4. Start Check Loop (every 2 seconds)
        self.update_status()
        GLib.timeout_add_seconds(2, self.update_status)

    def check_service_active(self):
        """Checks if the systemd watcher service is active"""
        try:
            # systemctl --user is-active returns 'active' and exit code 0 if running
            result = subprocess.run(
                ["systemctl", "--user", "is-active", self.service_name],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True
            )
            return result.returncode == 0
        except Exception:
            return False

    def update_status(self):
        """Updates icon and label based on real service status"""
        is_active = self.check_service_active()

        if is_active:
            self.indicator.set_icon(self.icon_active)
            # Green Circle Emoji for visibility
            self.item_label.set_label("CDSync: ðŸŸ¢ ACTIVE")
            self.item_toggle.set_label("Disable Sync")
        else:
            self.indicator.set_icon(self.icon_inactive)
            # Red/White Circle Emoji
            self.item_label.set_label("CDSync: ðŸ”´ STOPPED")
            self.item_toggle.set_label("Enable Sync")
        
        return True # Keep the GLib loop running

    def toggle_service(self, source):
        is_active = self.check_service_active()
        
        if is_active:
            # STOP
            subprocess.run(["systemctl", "--user", "stop", self.service_name])
            subprocess.run(["systemctl", "--user", "stop", self.timer_name])
            # Disable to prevent autostart if user explicitly stopped it
            subprocess.run(["systemctl", "--user", "disable", self.service_name])
            subprocess.run(["systemctl", "--user", "disable", self.timer_name])
        else:
            # START
            subprocess.run(["systemctl", "--user", "enable", self.service_name])
            subprocess.run(["systemctl", "--user", "enable", self.timer_name])
            subprocess.run(["systemctl", "--user", "start", self.service_name])
            subprocess.run(["systemctl", "--user", "start", self.timer_name])
        
        # Force immediate update
        self.update_status()

    def manual_sync(self, source):
        # Run core script in background
        core_script = os.path.join(self.base_dir, "cdsync-core.sh")
        subprocess.Popen(["/bin/bash", core_script])
        
        # Visual Feedback
        subprocess.run(["notify-send", "CDSync", "Manual sync started..."])

    def quit(self, source):
        Gtk.main_quit()

if __name__ == "__main__":
    # Allows Ctrl+C in terminal to kill the process
    signal.signal(signal.SIGINT, signal.SIG_DFL)
    
    app = CDSyncIndicator()
    Gtk.main()
